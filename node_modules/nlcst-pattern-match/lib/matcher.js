"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// MIT Â© 2017 azu
var NodeTypes_1 = require("./NodeTypes");
var debug = require("debug")("nlcst-pattern-match");
var toString = require("nlcst-to-string");
exports.isRegExp = function (v) {
    return Object.prototype.toString.call(v) === "[object RegExp]";
};
/**
 * Match actualValue with expectedValue
 * @param actualValue
 * @param expectedValue
 * @returns {boolean}
 */
function matchValue(actualValue, expectedValue) {
    if (actualValue === undefined || expectedValue === undefined) {
        return false;
    }
    // wildcard
    if (expectedValue === "*" && actualValue !== undefined) {
        return true;
    }
    else if (exports.isRegExp(expectedValue)) {
        // /pattern/
        return expectedValue.test(actualValue);
    }
    else if (Array.isArray(expectedValue)) {
        // value: ["a", "b"]
        return expectedValue.some(function (value) {
            return matchValue(actualValue, value);
        });
    }
    else if (typeof expectedValue === "object") {
        // data object
        return Object.keys(expectedValue).every(function (key) {
            return matchValue(actualValue[key], expectedValue[key]);
        });
    }
    return actualValue === expectedValue;
}
exports.matchValue = matchValue;
/**
 * Match actualNode with expectedNode
 * @param {Node} actualNode
 * @param {TagNode} expectedNode
 * @returns {boolean}
 */
function matchNode(actualNode, expectedNode) {
    // ignore other property. ore-ore property should be ignored
    var isMatch = ["type", "children", "value", "data"].every(function (key) {
        var expectedProp = expectedNode[key];
        if (!expectedProp) {
            return true;
        }
        var actualProp = actualNode[key];
        debug("Math: " + key + ": ", expectedProp, actualProp);
        if (key === "children") {
            var every = expectedProp.every(function (expectedChildNode, index) {
                var actualChildNode = actualProp[index];
                return matchNode(actualChildNode, expectedChildNode);
            });
            debug("RETURN:CIL", every);
            return every;
        }
        else {
            var expectedValues = Array.isArray(expectedProp) ? expectedProp : [expectedProp];
            var b = expectedValues.some(function (expectedValue) {
                return matchValue(actualProp, expectedValue);
            });
            debug("RETURN", b);
            return b;
        }
    });
    if (typeof expectedNode.isNegative === "boolean" && expectedNode.isNegative) {
        return !isMatch;
    }
    return isMatch;
}
exports.matchNode = matchNode;
/**
 * match actualNodes with expectedPatterns
 * @param {Sentence} actualNodes
 * @param {Sentence} expectedPatterns
 * @returns {MatchCSTResult[]}
 */
function match(actualNodes, expectedPatterns) {
    var expectedChildren = expectedPatterns;
    var tokenCount = expectedChildren.length;
    var matchTokens = [];
    var results = [];
    var currentTokenPosition = 0;
    var index = 0;
    var _loop_1 = function () {
        var actualChild = actualNodes[index];
        var expectedChild = expectedChildren[currentTokenPosition];
        // PatternNode
        if (NodeTypes_1.isPatternNode(expectedChild)) {
            var pattern = expectedChild.pattern;
            var afterAllChildren = actualNodes.slice(index);
            var startIndex_1 = afterAllChildren[0].position.start.offset;
            var text = toString(afterAllChildren);
            var matchResult = text.match(pattern);
            if (matchResult) {
                var progressLength = matchResult[0].length;
                var endIndex_1 = startIndex_1 + progressLength;
                var restChildren = afterAllChildren.slice(1);
                // fist token always added because already matchResult.
                matchTokens.push(afterAllChildren[0]);
                restChildren.forEach(function (restChild) {
                    var nodeOffset = restChild.position.end.offset;
                    if (startIndex_1 <= nodeOffset && nodeOffset <= endIndex_1) {
                        matchTokens.push(restChild);
                        index++;
                    }
                });
                currentTokenPosition += 1;
            }
            else {
                // reset position
                matchTokens.length = 0;
                currentTokenPosition = 0;
            }
        }
        else if (matchNode(actualChild, expectedChild)) {
            matchTokens.push(actualChild);
            currentTokenPosition += 1;
        }
        else {
            debug("FAIL", expectedChild);
            // reset position
            matchTokens.length = 0;
            currentTokenPosition = 0;
        }
        // match all tokens
        if (currentTokenPosition === tokenCount) {
            var tokens = matchTokens.slice();
            if (tokens.length === 0) {
                return "continue";
            }
            // match -> reset
            currentTokenPosition = 0;
            matchTokens.length = 0;
            var firstNode = tokens[0];
            var lastNode = tokens[tokens.length - 1];
            if (!firstNode.position) {
                throw new Error("The node has not position: " + firstNode);
            }
            if (!lastNode.position) {
                throw new Error("The node has not position: " + firstNode);
            }
            results.push({
                position: {
                    start: firstNode.position.start,
                    end: lastNode.position.end,
                    index: firstNode.position.start.offset
                },
                nodeList: tokens
            });
        }
    };
    for (index = 0; index < actualNodes.length; index++) {
        _loop_1();
    }
    return results;
}
exports.match = match;
//# sourceMappingURL=matcher.js.map