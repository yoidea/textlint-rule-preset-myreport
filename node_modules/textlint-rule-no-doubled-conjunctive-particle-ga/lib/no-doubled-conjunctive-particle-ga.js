// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _textlintRuleHelper = require("textlint-rule-helper");

var _kuromojin = require("kuromojin");

var _sentenceSplitter = _interopRequireWildcard(require("sentence-splitter"));

var _textlintUtilToString = _interopRequireDefault(require("textlint-util-to-string"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var defaultOptions = {
  separatorChars: ["。", "?", "!", "？", "！"]
}; // ref: https://stackoverflow.com/questions/2593637/how-to-escape-regular-expression-in-javascript

RegExp.escape = function (str) {
  return String(str).replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
};
/*
    1. Paragraph Node -> text
    2. text -> sentences
    3. tokenize sentence
    4. report error if found word that match the rule.

    TODO: need abstraction
 */


function _default(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var separatorChars = options.separatorChars || defaultOptions.separatorChars;
  var helper = new _textlintRuleHelper.RuleHelper(context);
  var Syntax = context.Syntax,
      report = context.report,
      getSource = context.getSource,
      RuleError = context.RuleError;
  return _defineProperty({}, Syntax.Paragraph, function (node) {
    if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
      return;
    }

    var source = new _textlintUtilToString.default(node);
    var text = source.toString();

    var isSentenceNode = function isSentenceNode(node) {
      return node.type === _sentenceSplitter.Syntax.Sentence;
    };

    var charRegExp = new RegExp("[" + RegExp.escape(separatorChars.join("")) + "]");
    var sentences = (0, _sentenceSplitter.default)(text, {
      charRegExp: charRegExp
    }).filter(isSentenceNode);
    return (0, _kuromojin.getTokenizer)().then(function (tokenizer) {
      var checkSentence = function checkSentence(sentence) {
        var tokens = tokenizer.tokenizeForSentence(sentence.raw);

        var isConjunctiveParticleGaToken = function isConjunctiveParticleGaToken(token) {
          return token.pos_detail_1 === "接続助詞" && token.surface_form === "が";
        };

        var conjunctiveParticleGaTokens = tokens.filter(isConjunctiveParticleGaToken);

        if (conjunctiveParticleGaTokens.length <= 1) {
          return;
        }

        var current = conjunctiveParticleGaTokens[0];
        var originalPosition = source.originalPositionFor({
          line: sentence.loc.start.line,
          column: sentence.loc.start.column + (current.word_position - 1)
        }); // padding position

        var padding = {
          line: originalPosition.line - 1,
          // matchLastToken.word_position start with 1
          // this is padding column start with 0 (== -1)
          column: originalPosition.column
        };
        report(node, new RuleError("\u6587\u4E2D\u306B\u9006\u63A5\u306E\u63A5\u7D9A\u52A9\u8A5E \"\u304C\" \u304C\u4E8C\u56DE\u4EE5\u4E0A\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059\u3002", padding));
        return current;
      };

      sentences.forEach(checkSentence);
    });
  });
}

;
//# sourceMappingURL=no-doubled-conjunctive-particle-ga.js.map