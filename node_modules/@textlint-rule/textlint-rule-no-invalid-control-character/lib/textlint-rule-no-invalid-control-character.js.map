{"version":3,"sources":["../src/textlint-rule-no-invalid-control-character.js"],"names":["execall","require","unicodeEscape","str","replace","c","charCodeAt","toString","substr","getName","matchChar","find","CONTROL_CHARACTER","code","char","name","DEFAULT_OPTION","allow","checkCode","checkImage","reporter","context","options","Syntax","RuleError","getSource","fixer","report","undefined","checkNode","text","node","controlCharacterPattern","results","forEach","index","result","sub","some","allowChar","ruleError","fix","removeRange","Str","CodeBlock","Code","Image","module","exports","linter"],"mappings":"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","file":"textlint-rule-no-invalid-control-character.js","sourcesContent":["// MIT Â© 2017 azu\n\"use strict\";\n\nconst execall = require(\"execall\");\nimport { CONTROL_CHARACTERS } from \"./CONTROL_CHARACTERS\";\n\n/**\n * Convert char to \\uXXXX\n * @param {string} str\n * @return {string}\n */\nconst unicodeEscape = str => {\n    return str.replace(/./g, c => {\n        return `\\\\u${`000${c.charCodeAt(0).toString(16)}`.substr(-4)}`;\n    });\n};\n\nconst getName = char => {\n    const matchChar = CONTROL_CHARACTERS.find(CONTROL_CHARACTER => CONTROL_CHARACTER.code === char);\n    if (!matchChar) {\n        return \"\";\n    }\n    return matchChar.name;\n};\n\nconst DEFAULT_OPTION = {\n    // Define allow char code like `\\u0019`\n    allow: [],\n    // Check code if it is true\n    checkCode: false,\n    // Check image title and alt text if it is true\n    checkImage: false\n};\n\nconst reporter = (context, options = {}) => {\n    const { Syntax, RuleError, getSource, fixer, report } = context;\n    const allow = options.allow || DEFAULT_OPTION.allow;\n    const checkCode = options.checkCode !== undefined ? options.checkCode : DEFAULT_OPTION.checkCode;\n    const checkImage = options.checkImage !== undefined ? options.checkImage : DEFAULT_OPTION.checkImage;\n    const checkNode = node => {\n        const text = getSource(node);\n        // Ignore \\r \\n \\t\n        const controlCharacterPattern = /([\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F])/g;\n        /**\n         * @type {Array<{match:string, sub:string[], index:number}>}\n         */\n        const results = execall(controlCharacterPattern, text);\n        results.forEach(result => {\n            const index = result.index;\n            const char = result.sub[0];\n            // if allow the `char`, ignore it\n            if (allow.some(allowChar => allowChar === char)) {\n                return;\n            }\n            const name = getName(char);\n            const ruleError = new RuleError(`Found invalid control character(${name} ${unicodeEscape(char)})`, {\n                index: index,\n                fix: fixer.removeRange([index, index + 1])\n            });\n            report(node, ruleError);\n        });\n    };\n    return {\n        [Syntax.Str](node) {\n            checkNode(node);\n        },\n        [Syntax.CodeBlock](node) {\n            if (checkCode) {\n                checkNode(node);\n            }\n        },\n        [Syntax.Code](node) {\n            if (checkCode) {\n                checkNode(node);\n            }\n        },\n        [Syntax.Image](node) {\n            if (checkImage) {\n                checkNode(node);\n            }\n        }\n    };\n};\n\nmodule.exports = {\n    linter: reporter,\n    fixer: reporter\n};\n"]}