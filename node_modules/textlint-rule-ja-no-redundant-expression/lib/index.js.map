{"version":3,"sources":["../src/index.js"],"names":["require","Dictionary","ExpectedType","tokenize","createMatchAll","replaceAll","text","from","to","split","join","replaceTokenWith","matcherToken","actualToken","specialTo","surface_form","tokensToString","tokens","map","token","isTokensAllowed","allows","length","matchedText","allowsMatchResults","createExpected","expected","matcherTokens","skipped","actualTokens","resultText","actualTokenIndex","index","_capture","STOP_REPLACE","createMessage","id","forEach","reporter","context","options","Syntax","RuleError","fixer","DefaultOptions","allowNodeTypes","BlockQuote","Link","ReferenceDef","Code","dictOptions","enabledDictionaryList","filter","dict","dictOption","disabled","matchAll","skipNodeTypes","ignoreNodeTypes","report","Paragraph","node","source","StringSource","toString","then","currentTokens","matchResults","matchResult","isAllowed","firstToken","lastToken","firstWordIndex","originalIndexFromIndex","Math","max","word_position","lastWordIndex","message","hasFixableResult","wordLength","fix","replaceTextRange","module","exports","linter"],"mappings":"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","sourcesContent":["// MIT © 2016 azu\n\"use strict\";\nimport { matchPatterns } from \"@textlint/regexp-string-matcher\";\nimport { wrapReportHandler } from \"textlint-rule-helper\";\nimport StringSource from \"textlint-util-to-string\";\nconst { Dictionary, ExpectedType } = require(\"./dictionary.js\")\n\nconst tokenize = require(\"kuromojin\").tokenize;\n\nconst createMatchAll = require(\"morpheme-match-all\");\n\n/**\n * textの中身をすべて置換する\n * @param {string} text\n * @param {string|undefined} from\n * @param {string} to\n * @returns {string}\n */\nconst replaceAll = (text, from, to) => {\n    return text.split(from).join(to);\n};\n\nconst replaceTokenWith = (matcherToken, actualToken, specialTo) => {\n    if (matcherToken[specialTo]) {\n        return matcherToken[specialTo](actualToken);\n    }\n    return actualToken.surface_form;\n};\n\n/**\n * tokensのsurface_formをつなげた文字列を返す\n * @param tokens\n * @returns {string}\n */\nconst tokensToString = tokens => {\n    return tokens.map(token => token.surface_form).join(\"\");\n};\n\n/**\n * \"allows\" オプションで許可されているかどうか\n * @param {*[]} tokens\n * @param {string[]} allows\n */\nconst isTokensAllowed = (tokens, allows) => {\n    if (allows.length === 0) {\n        return false;\n    }\n    const matchedText = tokensToString(tokens);\n    const allowsMatchResults = matchPatterns(matchedText, allows);\n    return allowsMatchResults.length > 0;\n};\n\n/**\n * マッチしたtokensを置換した結果の文字列を返す\n * 置換できなかった場合はnullを返す\n * @param {string} expected\n * @param {*[]} matcherTokens\n * @param {boolean[]} skipped\n * @param {*[]} actualTokens\n * @returns {null|string}\n */\nconst createExpected = ({ expected, matcherTokens, skipped, actualTokens }) => {\n    if (!expected) {\n        return null;\n    }\n    let resultText = expected;\n    let actualTokenIndex = 0;\n    for (let index = 0; index < matcherTokens.length; index++) {\n        const token = matcherTokens[index];\n        if (skipped[index]) {\n            resultText = replaceAll(resultText, token._capture, \"\");\n            continue;\n        }\n        if (token._capture) {\n            const to = replaceTokenWith(token, actualTokens[actualTokenIndex], \"_capture_to_expected\");\n            // _capture_to_expectedが\"STOP_REPLACE\"を返した場合は置換を取りやめる\n            if (to === ExpectedType.STOP_REPLACE) {\n                return null;\n            }\n            resultText = replaceAll(resultText, token._capture, to);\n        }\n        ++actualTokenIndex;\n    }\n    return resultText;\n};\n\nconst createMessage = ({ id, text, matcherTokens, skipped, actualTokens }) => {\n    let resultText = text;\n    let actualTokenIndex = 0;\n    matcherTokens.forEach((token, index) => {\n        if (skipped[index]) {\n            resultText = replaceAll(resultText, token._capture, \"\");\n            return;\n        }\n\n        if (token._capture) {\n            const to = replaceTokenWith(token, actualTokens[actualTokenIndex], \"_capture_to_message\");\n            resultText = replaceAll(resultText, token._capture, to);\n        }\n        ++actualTokenIndex;\n    });\n    return `【${id}】 ${resultText}\n解説: https://github.com/textlint-ja/textlint-rule-ja-no-redundant-expression#${id}`;\n};\n\nconst reporter = (context, options = {}) => {\n    const { Syntax, RuleError, fixer } = context;\n    const DefaultOptions = {\n        // https://textlint.github.io/docs/txtnode.html#type\n        allowNodeTypes: [Syntax.BlockQuote, Syntax.Link, Syntax.ReferenceDef, Syntax.Code],\n        dictOptions: {}\n    };\n    const dictOptions = options.dictOptions || DefaultOptions.dictOptions;\n    // \"disabled\": trueな辞書は取り除く\n    const enabledDictionaryList = Dictionary.filter(dict => {\n        const dictOption = dictOptions[dict.id] || {};\n        const disabled = typeof dictOption.disabled === \"boolean\" ? dictOption.disabled : dict.disabled;\n        return !disabled;\n    });\n    const matchAll = createMatchAll(enabledDictionaryList);\n    const skipNodeTypes = options.allowNodeTypes || DefaultOptions.allowNodeTypes;\n    return wrapReportHandler(\n        context,\n        {\n            ignoreNodeTypes: skipNodeTypes\n        },\n        report => {\n            return {\n                [Syntax.Paragraph](node) {\n                    const source = new StringSource(node);\n                    const text = source.toString();\n                    return tokenize(text).then(currentTokens => {\n                        /**\n                         * @type {MatchResult[]}\n                         */\n                        const matchResults = matchAll(currentTokens);\n                        matchResults.forEach(matchResult => {\n                            const dictOption = dictOptions[matchResult.dict.id] || {};\n                            // \"allows\" オプションにマッチした場合はエラーを報告しない\n                            const allows = dictOption.allows || matchResult.dict.allows;\n                            const isAllowed = isTokensAllowed(matchResult.tokens, allows);\n                            if (isAllowed) {\n                                return;\n                            }\n                            // エラー報告\n                            const firstToken = matchResult.tokens[0];\n                            const lastToken = matchResult.tokens[matchResult.tokens.length - 1];\n                            const firstWordIndex = source.originalIndexFromIndex(\n                                Math.max(firstToken.word_position - 1, 0)\n                            );\n                            const lastWordIndex = source.originalIndexFromIndex(\n                                Math.max(lastToken.word_position - 1, 0)\n                            );\n                            // エラーメッセージ\n                            const message =\n                                createMessage({\n                                    id: matchResult.dict.id,\n                                    text: matchResult.dict.message,\n                                    matcherTokens: matchResult.dict.tokens,\n                                    skipped: matchResult.skipped,\n                                    actualTokens: matchResult.tokens\n                                });\n                            // 置換結果\n                            const expected = createExpected({\n                                expected: matchResult.dict.expected,\n                                matcherTokens: matchResult.dict.tokens,\n                                skipped: matchResult.skipped,\n                                actualTokens: matchResult.tokens\n                            });\n                            const hasFixableResult = expected && tokensToString(matchResult.tokens) !== expected;\n                            if (hasFixableResult) {\n                                const wordLength = lastToken.surface_form.length;\n                                report(\n                                    node,\n                                    new RuleError(message, {\n                                        index: firstWordIndex,\n                                        fix: fixer.replaceTextRange(\n                                            [firstWordIndex, lastWordIndex + wordLength],\n                                            expected\n                                        )\n                                    })\n                                );\n                            } else {\n                                report(\n                                    node,\n                                    new RuleError(message, {\n                                        index: firstWordIndex\n                                    })\n                                );\n                            }\n                        });\n                    });\n                }\n            };\n        }\n    );\n};\nmodule.exports = {\n    linter: reporter,\n    fixer: reporter\n};\n"],"file":"index.js"}