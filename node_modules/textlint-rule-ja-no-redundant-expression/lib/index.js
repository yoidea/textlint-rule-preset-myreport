// MIT © 2016 azu
"use strict";

var _regexpStringMatcher = require("@textlint/regexp-string-matcher");

var _textlintRuleHelper = require("textlint-rule-helper");

var _textlintUtilToString = _interopRequireDefault(require("textlint-util-to-string"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require("./dictionary.js"),
    Dictionary = _require.Dictionary,
    ExpectedType = _require.ExpectedType;

var tokenize = require("kuromojin").tokenize;

var createMatchAll = require("morpheme-match-all");
/**
 * textの中身をすべて置換する
 * @param {string} text
 * @param {string|undefined} from
 * @param {string} to
 * @returns {string}
 */


var replaceAll = function replaceAll(text, from, to) {
  return text.split(from).join(to);
};

var replaceTokenWith = function replaceTokenWith(matcherToken, actualToken, specialTo) {
  if (matcherToken[specialTo]) {
    return matcherToken[specialTo](actualToken);
  }

  return actualToken.surface_form;
};
/**
 * tokensのsurface_formをつなげた文字列を返す
 * @param tokens
 * @returns {string}
 */


var tokensToString = function tokensToString(tokens) {
  return tokens.map(function (token) {
    return token.surface_form;
  }).join("");
};
/**
 * "allows" オプションで許可されているかどうか
 * @param {*[]} tokens
 * @param {string[]} allows
 */


var isTokensAllowed = function isTokensAllowed(tokens, allows) {
  if (allows.length === 0) {
    return false;
  }

  var matchedText = tokensToString(tokens);
  var allowsMatchResults = (0, _regexpStringMatcher.matchPatterns)(matchedText, allows);
  return allowsMatchResults.length > 0;
};
/**
 * マッチしたtokensを置換した結果の文字列を返す
 * 置換できなかった場合はnullを返す
 * @param {string} expected
 * @param {*[]} matcherTokens
 * @param {boolean[]} skipped
 * @param {*[]} actualTokens
 * @returns {null|string}
 */


var createExpected = function createExpected(_ref) {
  var expected = _ref.expected,
      matcherTokens = _ref.matcherTokens,
      skipped = _ref.skipped,
      actualTokens = _ref.actualTokens;

  if (!expected) {
    return null;
  }

  var resultText = expected;
  var actualTokenIndex = 0;

  for (var index = 0; index < matcherTokens.length; index++) {
    var token = matcherTokens[index];

    if (skipped[index]) {
      resultText = replaceAll(resultText, token._capture, "");
      continue;
    }

    if (token._capture) {
      var to = replaceTokenWith(token, actualTokens[actualTokenIndex], "_capture_to_expected"); // _capture_to_expectedが"STOP_REPLACE"を返した場合は置換を取りやめる

      if (to === ExpectedType.STOP_REPLACE) {
        return null;
      }

      resultText = replaceAll(resultText, token._capture, to);
    }

    ++actualTokenIndex;
  }

  return resultText;
};

var createMessage = function createMessage(_ref2) {
  var id = _ref2.id,
      text = _ref2.text,
      matcherTokens = _ref2.matcherTokens,
      skipped = _ref2.skipped,
      actualTokens = _ref2.actualTokens;
  var resultText = text;
  var actualTokenIndex = 0;
  matcherTokens.forEach(function (token, index) {
    if (skipped[index]) {
      resultText = replaceAll(resultText, token._capture, "");
      return;
    }

    if (token._capture) {
      var to = replaceTokenWith(token, actualTokens[actualTokenIndex], "_capture_to_message");
      resultText = replaceAll(resultText, token._capture, to);
    }

    ++actualTokenIndex;
  });
  return "\u3010".concat(id, "\u3011 ").concat(resultText, "\n\u89E3\u8AAC: https://github.com/textlint-ja/textlint-rule-ja-no-redundant-expression#").concat(id);
};

var reporter = function reporter(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var Syntax = context.Syntax,
      RuleError = context.RuleError,
      fixer = context.fixer;
  var DefaultOptions = {
    // https://textlint.github.io/docs/txtnode.html#type
    allowNodeTypes: [Syntax.BlockQuote, Syntax.Link, Syntax.ReferenceDef, Syntax.Code],
    dictOptions: {}
  };
  var dictOptions = options.dictOptions || DefaultOptions.dictOptions; // "disabled": trueな辞書は取り除く

  var enabledDictionaryList = Dictionary.filter(function (dict) {
    var dictOption = dictOptions[dict.id] || {};
    var disabled = typeof dictOption.disabled === "boolean" ? dictOption.disabled : dict.disabled;
    return !disabled;
  });
  var matchAll = createMatchAll(enabledDictionaryList);
  var skipNodeTypes = options.allowNodeTypes || DefaultOptions.allowNodeTypes;
  return (0, _textlintRuleHelper.wrapReportHandler)(context, {
    ignoreNodeTypes: skipNodeTypes
  }, function (report) {
    return _defineProperty({}, Syntax.Paragraph, function (node) {
      var source = new _textlintUtilToString.default(node);
      var text = source.toString();
      return tokenize(text).then(function (currentTokens) {
        /**
         * @type {MatchResult[]}
         */
        var matchResults = matchAll(currentTokens);
        matchResults.forEach(function (matchResult) {
          var dictOption = dictOptions[matchResult.dict.id] || {}; // "allows" オプションにマッチした場合はエラーを報告しない

          var allows = dictOption.allows || matchResult.dict.allows;
          var isAllowed = isTokensAllowed(matchResult.tokens, allows);

          if (isAllowed) {
            return;
          } // エラー報告


          var firstToken = matchResult.tokens[0];
          var lastToken = matchResult.tokens[matchResult.tokens.length - 1];
          var firstWordIndex = source.originalIndexFromIndex(Math.max(firstToken.word_position - 1, 0));
          var lastWordIndex = source.originalIndexFromIndex(Math.max(lastToken.word_position - 1, 0)); // エラーメッセージ

          var message = createMessage({
            id: matchResult.dict.id,
            text: matchResult.dict.message,
            matcherTokens: matchResult.dict.tokens,
            skipped: matchResult.skipped,
            actualTokens: matchResult.tokens
          }); // 置換結果

          var expected = createExpected({
            expected: matchResult.dict.expected,
            matcherTokens: matchResult.dict.tokens,
            skipped: matchResult.skipped,
            actualTokens: matchResult.tokens
          });
          var hasFixableResult = expected && tokensToString(matchResult.tokens) !== expected;

          if (hasFixableResult) {
            var wordLength = lastToken.surface_form.length;
            report(node, new RuleError(message, {
              index: firstWordIndex,
              fix: fixer.replaceTextRange([firstWordIndex, lastWordIndex + wordLength], expected)
            }));
          } else {
            report(node, new RuleError(message, {
              index: firstWordIndex
            }));
          }
        });
      });
    });
  });
};

module.exports = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=index.js.map